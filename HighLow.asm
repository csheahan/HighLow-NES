;;;;;;;;;;;;;;;;
;;   Header   ;;
;;;;;;;;;;;;;;;;

;; For use with NESASM3 compiler

  .inesprg 1   ; 1x 16KB PRG code
  .ineschr 1   ; 1x  8KB CHR data
  .inesmap 0   ; mapper 0 = NROM, no bank swapping
  .inesmir 1   ; background mirroring



;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;   Declare Variables   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

  .rsset $0000  ; start variables at ram location 0

;; Variables
;; Structure as follows:
;; var_name .rs #_of_bytes_to_reserve
RandomNum            .rs 1 ; Random number generated through seed. Determines card chosen.
Counter              .rs 1 ; A psuedo random number generated by counting the frames
PreviousCard         .rs 1 ; The current card showing: to be compared to Random_Num
Choice               .rs 1 ; The choice of the player. 0 = higher, 1 = lower
PlayerOneController  .rs 1 ; Keeps track of Player 1's buttons
ControllerHandler    .rs 1 ; Handles the not pressed (0) and pressed (1) position of controller
StreakOnes           .rs 1 ; Ones place of streak
StreakTens           .rs 1 ; Tens place of streak
StreakHundreds       .rs 1 ; Hundreds place of streak
HighScoreOnes        .rs 1 ; High score ones place
HighScoreTens        .rs 1 ; High score tens place
HighScoreHundreds    .rs 1 ; High score hundreds place
GameState            .rs 1 ; State of the game
TitleSelectSpot      .rs 1 ; Keeps place of selector on title screen


;; Constants
;; Structure as follows:
;; var_name = value
ACE = $00 ; #ACE if number is 0
TWO = $01
THREE = $02
FOUR = $03
FIVE = $04
SIX = $05
SEVEN = $06
EIGHT = $07
NINE = $08
TEN = $09
JACK = $0A
QUEEN = $0B
KING = $0C
TITLESCREEN = $00
GAMESCREEN = $01
INSTRUCTIONSSCREEN = $02
START = $00
INSTRUCTIONS = $01


;;;;;;;;;;;;;;;;;;;
;;   Main Code   ;;
;;;;;;;;;;;;;;;;;;;

  .bank 0
  .org $C000
;; The Reset interrupt, this runs when the power button is first pressed
;; Most of this code is just standard starup code though, so same for most programs
RESET:
  SEI          ; disable IRQs
  CLD          ; disable decimal mode
  LDX #$40
  STX $4017    ; disable APU frame IRQ
  LDX #$FF
  TXS          ; Set up stack
  INX          ; now X = 0
  STX $2000    ; disable NMI
  STX $2001    ; disable rendering
  STX $4010    ; disable DMC IRQs

vblankwait1:       ; First wait for vblank to make sure PPU is ready
  BIT $2002
  BPL vblankwait1

clrmem:
  LDA #$00
  STA $0000, x
  STA $0100, x
  STA $0300, x
  STA $0400, x
  STA $0500, x
  STA $0600, x
  STA $0700, x
  LDA #$FE
  STA $0200, x
  INX
  BNE clrmem

vblankwait2:      ; Second wait for vblank, PPU is ready after this
  BIT $2002
  BPL vblankwait2

;; Load our background and sprite palettes, in that order
LoadPalettes:
  LDA $2002             ; read PPU status to reset the high/low latch, as the PPU is 16 bits
  LDA #$3F
  STA $2006             ; write the high byte of $3F00 address
  LDA #$00
  STA $2006             ; write the low byte of $3F00 address
  LDX #$00                   ; start X out at 0
LoadPalettesLoop:
  LDA palette, x        ; load data from address
  STA $2007             ; write to PPU
  INX
  CPX #$20
  BNE LoadPalettesLoop

  JSR DrawTitleScreen
  JSR TitleScreenSelectorStart

;; Loads the Attribute Table, using the data from the Secondary Code section
LoadAttribute:
  LDA $2002             ; read PPU status
  LDA #$23
  STA $2006
  LDA #$C0
  STA $2006
  LDX #$00
LoadAttributeLoop1:
  LDA attribute, x
  STA $2007
  INX
  CPX #$3C              ; Compare to #_of_bytes
  BNE LoadAttributeLoop1

;; The initial startup
InitialStartup:
  JSR StartupState

;; Next enable the sprites and background
  LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  STA $2000
  LDA #%00011110   ; enable sprites, enable background, no clipping on left side
  STA $2001

;; Use an infinite loop to stop execution, rest of code will be run through
;; NMI interrupt: running 50/60 times per second
Forever:
  JMP Forever     ;jump back to Forever, infinite loop



;;;;;;;;;;;;;
;;   NMI   ;;
;;;;;;;;;;;;;

;; The NMI interrupt is called every frame refresh
;; which is 60 per second for NTSC and 50 per second for PAL
NMI:
  LDA #$00
  STA $2003       ; set the low byte (00) of the RAM address
  LDA #$02
  STA $4014       ; set the high byte (02) of the RAM address, start the transfer

  LDA GameState
  CMP #GAMESCREEN
  BEQ DrawGamescreen
  JMP PPUCleanup

DrawGamescreen
  ;; Edit Background, such as streaks/highscore, here
  JSR DrawStreak
  JSR DrawHighScore

PPUCleanup:
  ;; This is the PPU clean up section, so rendering the next frame starts properly.
  LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  STA $2000
  LDA #%00011110   ; enable sprites, enable background, no clipping on left side
  STA $2001
  LDA #$00         ; tell the ppu there is no background scrolling
  STA $2005
  STA $2005

StartPlayState:

  LDA GameState
  CMP #TITLESCREEN
  BEQ PlayTitleState
  CMP #GAMESCREEN
  BEQ PlayGameState
  CMP #INSTRUCTIONSSCREEN
  BEQ InstructionsScreenState
  JMP EndGameState

InstructionsScreenState:
  JSR ReadController1
  LDA PlayerOneController
  ORA #%00000000
  BEQ ControllerNotPressed
  LDA ControllerHandler
  CMP #$01
  BEQ EndGameState
CheckSelectPressedInstructions:
  LDA PlayerOneController
  AND #%00100000
  BEQ EndGameState
  JSR ReturnToTitle

PlayTitleState:
  JSR ReadController1
  LDA PlayerOneController
  ORA #%00000000
  BEQ ControllerNotPressed
  LDA ControllerHandler
  CMP #$01
  BEQ EndGameState
CheckStartPressed:
  LDA PlayerOneController
  AND #%00010000 ; Start
  BEQ CheckSelectPressed
  JSR HandleTitleStart
CheckSelectPressed:
  LDA PlayerOneController
  AND #%00100000 ; Select
  BEQ EndGameState
  JSR TitleSelect


PlayGameState:
  ;; Have a counter which counts frames. The psuedo-"random" number generator
  INC Counter

  ;; Update Game State
  JSR ReadController1

  ;; Check to see if the controller was both pressed and pressed last frame
  ;; (held down)
  LDA PlayerOneController
  ORA #%00000000 ; Check to see if up/down pressed
  BEQ ControllerNotPressed ; one of the bits are 1, so controller is pressed
  LDA ControllerHandler
  CMP #$01 ; Controller already held down
  BEQ EndGameState
  JMP CheckUpPressed
ControllerNotPressed:
  LDA #$00 ; Controller not pressed
  STA ControllerHandler ; Mark
  JMP EndGameState ; No controller = no action, jump to end

CheckUpPressed:
  LDA PlayerOneController
  AND #%00001000  ; Will return non-0 if up is pressed
  BEQ CheckDownPressed ; Up is not pressed if 0
  JSR UpPressed
CheckDownPressed:
  LDA PlayerOneController
  AND #%00000100  ; Down Pressed
  BEQ Player1ControllerDone
  JSR DownPressed
Player1ControllerDone:

EndGameState:
  RTI             ; return from interrupt



;;;;;;;;;;;;;;;;;;;;;
;;   SubRoutines   ;;
;;;;;;;;;;;;;;;;;;;;;

;; Skip past subroutine code. This is just a precaution for
;; any shenanigans
SkipSubroutines:
  LDA #$00
  JMP DoneSubRoutines

  .include "subroutines.asm"
  .include "cardmanipulations.asm"

DoneSubRoutines:



;;;;;;;;;;;;;;;;;;;;;;;;
;;   Secondary Code   ;;
;;;;;;;;;;;;;;;;;;;;;;;;

  .bank 1
  .org $E000

  .include "data.asm"

  .org $FFFA     ;first of the three vectors starts here
  .dw NMI        ;when an NMI happens (once per frame if enabled) the 
                   ;processor will jump to the label NMI:
  .dw RESET      ;when the processor first turns on or is reset, it will jump
                   ;to the label RESET:
  .dw 0          ;external interrupt IRQ is not used in this tutorial



;;;;;;;;;;;;;;;;;;
;;   Graphics   ;;
;;;;;;;;;;;;;;;;;;

  .bank 2
  .org $0000
  .incbin "cards.chr"   ; Graphics file containing card sprites and background